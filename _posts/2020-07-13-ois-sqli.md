---
layout: post
title: BigProf-Software Online Invoicing System SQL Injection 
tags: [CVE-Writeup, SQLi]
author: Ingredous Labs
comment: true
---

```
Software Name: Online Invoicing System
Software Version: 2.8
Software Developer: https://bigprof.com/
Link to Software: https://github.com/bigprof-software/online-invoicing-system
Vulnerability: SQL Injection
CVE ID: Pending
Pending
```

# Introduction

Online Invoicing System suffers from a SQL Injection found in `/membership_passwordReset.php` which is the endpoint that is responsible for self password resets. An unauthenticated attacker is able to input a specially crafted payload which can result in sensitive information being extracted from the database eventually leading into an application takeover. This vulnerability is introduced as a result of the developer trying to roll their own sanitization implementation in order to allow the application to be used in legacy environments.

# Exploitation Details

**PHP Version used throughout this writeup: PHP 7.4.8**

Exploring the sink found in: `app/membership_passwordReset.php`:

![Screenshot]({{ site.baseurl }}/images/posts/2020/ois-sql/1.png)

On Line 5, `$username` is initialized with the value returned from passing the user-input into the `makeSafe()` function. The user-input is passed in through the `username` parameter found in the body of the following POST request:

~~~
POST /membership_passwordReset.php HTTP/1.1
Host: localhost
Content-Length: 38
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://localhost
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: http://localhost/membership_passwordReset.php
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: online_inovicing_system=5oknklsfinhab277rupidv112o
Connection: close

username=test&email=&reset=Ok
~~~

After `$username` is intialized, the application eventually constructs and executes a SQL query which contains the user-input as shown on Line 21:

~~~php
$where = '';
		if($username){
			$where = "lcase(memberID)='{$username}'";
		}elseif($email){
			$where = "email='{$email}'";
		}
$res = sql("select * from membership_users where {$where} limit 1", $eo);
~~~

However as `$username` is first passed into the `makeSafe()` function before being concantenated into the query, it appears to be sanitized.

Let's explore the `makeSafe()` function found in `app/admin/incFunctions.php` to learn more:

![Screenshot]({{ site.baseurl }}/images/posts/2020/ois-sql/2.png)

From a high level overview, it can be inferred that this function is indeed responsible for sanitizing user-input by escaping any potentially dangerous characters. However to understand how this function works in greater detail, lets break it down line by line.

On Line 2, the application performs a ternary operation in order to re-initalize the value of `$string` (which is the value of the user-input passed into this function).

~~~php
if($is_gpc) $string = (get_magic_quotes_gpc() ? stripslashes($string) : $string);
~~~

As shown by the function definition, `$is_gpc` is set to `True` by default meaning the above line will always be executed. The ternary operation is then performed based on the result returned from the `get_magic_quotes_gpc()` function. 

Some quick context regarding the `get_magic_quotes_gpc()` function from the PHP Docs:

> Returns 0 if magic_quotes_gpc is off, 1 otherwise. Or always returns false as of PHP 5.4.0.

The last line here is key. As of "newer" PHP Versions, this will always result in false meaning that the ternary operation will never call the `stripslashes()` function on the user-input but re-initalize it the way it is. This isn't deterimental as there is additional logic performed in the `makeSafe()` function, however we'll circle back to this at the end.

After `$string` is re-initalized, the function continues. On Line 6, the application initalizes `$na` which is an array composed of potentially dangerous characters that can result in an injection such as backslashes, null-bytes, carriage returns, line feeds, etc. These are the same characters in which PHP's `mysqli_real_escape_string()` function escapes. Finally two booleans `$escaped` and `$nosc` are initialized with the value being `true`:

~~~php
// prevent double escaping
		$na = explode(',', "\x00,\n,\r,',\",\x1a");
		$escaped = true;
        $nosc = true; // no special chars exist
~~~

Moving forward, the application then enters a for loop which iterates over the bad characters stored in the `$na` array. This loop is interesting in how it works because it initializes two new variables:

`$dan`
`$esdan`

~~~php
foreach($na as $ns){
			$dan = substr_count($string, $ns);
			$esdan = substr_count($string, "\\{$ns}");
			if($dan != $esdan) $escaped = false;
			if($dan) $nosc = false;
        }
~~~

The application takes the value of the user-input which is stored in `$string`, the bad character in the current iteration and calls the `substr_count()` function against both which returns the number of occurences of the bad character found in `$string`. This value is then stored in `$dan`:

~~~php
$dan = substr_count($string, $ns);
~~~

The application then nearly performs the same thing however this time it passes an escaped variant of the bad character to see if any matches are found in the string. The returned value is then stored in `$esdan`:

~~~php
$esdan = substr_count($string, "\\{$ns}");
~~~

Finally the application then performs a comparison to see if the value of `$dan` and `$esdan` are different. If these values are different, this means that a character from the blacklist was found un-escaped in the user-input and if so `$escaped` is set to `false`.

~~~php
if($dan != $esdan) $escaped = false;
~~~


Lastly the application checks if `$dan` is true meaning if there was one or more occurence of a blacklist character found in the user input. If so, `$nosc` is set to false and the function moves on:

~~~php
if($dan) $nosc = false;
~~~

At this point, we have reached the final logic in the application which is only triggered if `$nosc` resulted in false earlier in the function (meaning that a blacklist character was found):

~~~php
if($nosc){
			// find unescaped \
			$dan = substr_count($string, '\\');
			$esdan = substr_count($string, '\\\\');
			if($dan != $esdan * 2) $escaped = false;
        }
~~~

To quickly break down this function's logic, it compares the number of escaped backslashes and unescaped backslashes found in the user-input. The logic here is that if the number of escaped backslashes (meaning a backslash followed immediately by another backslash) is not double the amount of backslashes found in the user-input, there is an un-escaped character and `$escaped` is set to false. What may seem confusing at first is you would think that in order to reach this function, `$escaped` would've already been set to false earlier, however keep in mind that you can reach this function if your user-input contains any blacklist character whether escaped or unescaped. 

Finally we reach the return statement of the function, which is another ternary operation:

~~~php
return ($escaped ? $string : db_escape($string));
~~~

This ternary condition takes the value of `$escaped` and if `true`, returns the value of `$string` directly. However if `$escaped` results in false, the user-input is then passed into the `db_escape()` function which is essentially a wrapper function over `mysql?_escape_string` (essentially depending on your version of PHP):

~~~php
	function db_escape($str = NULL, $link = NULL){
		if(!$link) $link = db_link();
		switch(DATABASE){
			case 'mysql':
				if(function_exists('mysql_real_escape_string'))    return mysql_real_escape_string($str, $link);
				return mysql_escape_string($str);
			case 'mysqli':
				return mysqli_real_escape_string($link, $str);
		}
	}
~~~

Taking a step back, we can see that this logic seems to be fairly sound. However there is one small flaw here that can result in a fatal vulnerability.























# Proof of Concept

