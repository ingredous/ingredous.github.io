---
layout: post
title: Tale of RMI Exploitation in 2021
tags: [Exploitation, Reference]
author: Ingredous Labs
comment: true
---

# Introduction
The aim of this blog post is two-fold. The first goal is to provide a detailed walkthrough of how Remote Code Execution was achieved by Deserialization via RMI. While the second goal is to provide supporting evidence of how providing source code during an engagement will yield many more findings which wouldn't have been possible to find otherwise.

During a recent engagement, a remote code execution vulnerability 

## RMI TL;DR
As the basics of RMI's inner-workings and how it can be exploited has been extensively covered in the past, this section will provide a very quick high level overview for those who might be unfamiliar with the service. References will be provided at the end of the section to resources which cover this in far greater detail.

RMI stands for Remote Method Invocation and is a Java propietary protocol. RMI is practically the object-oriented equivalent of RPC (Remote Procedure Call) and was developed to allow developers to implement client/server applications in Java. The basic functionality of RMI is that it allows an object running in one Java application (the client) to invoke methods on an object running in another Java application (the server).

RMI consists of three components:
- Server
- Client
- Registry

The responsiblity of the server is to export a remote object and bind an instance of it to the registry using a name. The registry itself is used as a lookup service (similar to how DNS works) which allows the client to lookup a name of the object instance which was bound by the server. Finally if the registry locates the instance of the object, the reference to the object (living on the server) is returned to the client. The reference that's returned to the client is known as the stub.

In order to allow the instance of the server-side object to be remotely interactable, the server must define an interface which extends the [Remote interface](https://docs.oracle.com/javase/7/docs/api/java/rmi/Remote.html#:~:text=The%20Remote%20interface%20serves%20to,rmi.). Within this interface, be sure to provide the empty method definitions for the methods which will be available to be remotely called.

The interface that's defined must be known by both the client and the server.

Lastly, the RMI Registry can be on a separate host from the server, however its quite common to spawn the registry on the same host from where the server is running especially if there is only one application binding services to the registry.

The following diagram provides a high level overview of the information described above:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/diagram.png)

## JEP 290
2016 was a bad year for RMI as it was discovered by Moritz Bechler that it was possible to leverage exploitation in the RMI Registry by passing in a malicious serialized object as a parameter to the `bind` method of the naming registry. In order to exploit this vector, an RMI Registry must be accessible over the Internet and if so an attacker would be able to write a client which would attempt to bind a malicious object to the registry. However its not fairly common for the registry to be exposed over the Internet but rather living in the intranet. This appears to be corroborated by Shodan because as of the time of writing this post, there are only 7,030 instances of RMI Registries which can be access over the Internet. 

Although if an attacker is able to gain access to the internal network as a result of other means, if a host running the RMI Registry was to be discovered this could have resulted in an easy pivot (especially for red-team engagements).

In response to this, Java released JEP 290 shortly after Belcher's research. Due to the severity of the vulnerability, JEP 290 was backported to several older Java versions as well. JEP 290 introduced serialization filters which essentially mitigated this exploitation technique.

## Exploitation after JEP 290
It was discovered that it was possible to exploit RMI on the application level. Due to how RMI works, upon the client invoking a method on the stub which contains arguments, these arguments are then serialized when sent over the wire which are then deserialized on the receiving end. If the method accepts an non-primitive type argument such as Strings and Objects in Java, the `.readObject()` method is called on the argument. 

An example of such a method is shown below:

```java
String convertDate(Date today) throws RemoteException;
```

As such if a method is discovered that can be remotely invoked and accepts a non-primitive type, this can result in exploitation via deserialization as a malicious object can be passed.  However as mentioned in the blog post by Mogwai Labs, an update released in January 2020 mitigated this exploitation technique in scenarios where Strings are passed as arguments. 

The caveat here however is that an attacker will need to know how the interface which is used by the RMI service was implemented in order to have knowledge of the methods which allow for arbitrary objects to be passed.

## Method Signatures
The way that RMI determines which method should be invoked on the server by the client is by using method signatures. The way that method signatures work is that RMI generates a SHA1 hash using the method name, return type, and the argument types. The names of the arguments themselves don't make a difference. This process is done both on the client and server side. Upon the client call a method, the hashes are compared and if one matches that respective method is invoked. 

As mentioned in the section above, in a blackbox scenario where the attacker doesn't have knowledge on how the interface was implemented it would be pretty much impossible to leverage exploitation.

In response to this, [RMIScout](https://github.com/BishopFox/rmiscout) was released by BishopFox which bruteforces the method signatures of exposed RMI Interfaces to guess the method implementations. The way `RMIScout` works is by using a wordlist of signatures along with wordlist of common method names and parameter lists to attempt to determine whether such a method definition exists. Apart from the signature bruteforcing functionality, if a method is indeed discovered which is deemed vulnerable the tool can be used to leverage exploitation.

As such the method signature bruteforcing functionality of [RMIScout](https://github.com/BishopFox/rmiscout) is typically used as a last resort in black-box scenarios where source code is not made available.

## Exploitation Discovery
During a recent pentest engagement, it was discovered that there was a method which accepts an arbitary object as an argument. However the finding was only made possible due to the developers providing the source code. Without the source code, this would have been impossible to discover due to how the developers implemented RMI in this context.

Please note: the actual implementations of code shown below has been severely modified to protect the integrity of the assessment.

An interface was discovered which extends from `Remote`:

`IExampleServiceReg.java`:

```java
package RMIExploitationDemo;

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface IExampleServiceReg extends Remote {
    ExampleService getService(String id) throws RemoteException;
}
```

The interface defines the `getService()` method which accepts an argument of type String and returns a type of `ExampleService`.

`ExampleService.java`:

```java
package RMIExploitationDemo;

import java.rmi.Remote;

public interface ExampleService extends Remote {
}
```

Afterwards, the implemenation of this interface was examined:

`ExampleServiceRegImpl.java`:

```java
package RMIExploitationDemo;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.HashMap;
import java.util.Map;

public class ExampleServiceRegImpl extends UnicastRemoteObject implements IExampleServiceReg {
    private Map items = new HashMap();

    protected ExampleServiceRegImpl() throws RemoteException {
        ServiceA a = new ServiceA();
        items.put("Service A", a);
        ServiceB b = new ServiceB();
        items.put("Service B", b);
    }

    public ExampleService getService(String id) throws RemoteException {
        return (ExampleService) items.get(id);
    }
}

As shown above, a map by the name of `items` is initalized. Further on when the constructor is called, two new objects are instantiated which are of types `ServiceA` and `ServiceB`. The respective instances of these objects are then stored in the `items` map. Finally the `getService()` method is concretely implemented which returns a value from the `items` HashMap associated with the key which is the passed-in String. The instances of these objects which were stored in the `items` map will be further explored shortly.

Taking a closer look at how the server binds the remote object to the registry:

`Server.java`:

```java
package RMIExploitationDemo;

import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class Server {
    public static void main(String[] args) {
        try {
            LocateRegistry.createRegistry(1099);
            Naming.bind("example-service", new ExampleServiceRegImpl());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

An RMI Registry was spawned on port 1099, a the server registered the object to the registry with the name of `example_service`.

This can be confirmed by running the NSE `rmi-dumpregistry` script using nmap which connects to a remote RMI registry and attempts to dump all of its objects:

```sh
$ nmap --script rmi-dumpregistry -p1099 localhost

Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-14 10:50 PDT
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00022s latency).
Other addresses for localhost (not scanned): ::1

PORT     STATE SERVICE
1099/tcp open  rmiregistry
| rmi-dumpregistry:
|   example-service
|      implements java.rmi.Remote, RMIExploitationDemo.IExampleServiceReg,
|     extends
|       java.lang.reflect.Proxy
|       fields
|           Ljava/lang/reflect/InvocationHandler; h
|             java.rmi.server.RemoteObjectInvocationHandler
|             @192.168.1.3:61867
|             extends
|_              java.rmi.server.RemoteObject

Nmap done: 1 IP address (1 host up) scanned in 0.24 seconds
```

The scan output shows that nmap discovered the registered name of the object `example-service` along with the name of the interface `IExampleServiceReg`.


## Writing the Malicious RMI Client

At this point in time, an RMI client can be written to interact with the `example-service` that is binded to the registry. 

The implementation will look like the following:

`Client.java`

```java
1 package RMIClientDemo;
2 
3 import java.rmi.NotBoundException;
4 import java.rmi.RemoteException;
5 import java.rmi.registry.LocateRegistry;
6 import java.rmi.registry.Registry;
7 
8 public class Client {
9     public static void main(String[] args) throws RemoteException, NotBoundException {
10         Registry naming = LocateRegistry.getRegistry("localhost", 1099);
11         IExampleServiceReg example_service = (IExampleServiceReg) naming.lookup("example-service");
12         System.out.println(example_service.getService("test"));
13     }
14 
15 }
16 
```

Shown on Line 10, `naming` is instantiated which obtains the remote object registry. Afterwards on Line 11, the client queries the registry for the `example-service` and the returned stub is cast of type `IExampleServiceReg` and is initialized as `example_service`. This means that `example_service` is able to call the methods which are defined in the `IExampleServiceReg` interface. 

It was mentioned earlier in the blog post, that the client will need to know the interface which is defined by the server. As such, the `IExampleServiceReg` interface will need to be created on the client-side as well (the contents of the interface are shown above).

As shown in the `IExampleServiceReg` interface, the `getService()` method will have a return type of `ExampleService`. In this scenario `ExampleService` is an interface and in order for the client to compile, the `ExampleService` interface must be created as well.

Lastly on Line 12, the sub now calls the `getService()` method with an arbitrary String just to confirm the client has the ability to interact with the stub.

However when running the client, the following error is thrown:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/error.png)

This error occurs because the `IExampleServiceReg` interface which was created on the server side lives in a different package on the client-side. Due to this, RMI is unable to locate the interface on the client-side as its looking for it using the [change this] path defined on the server-side.

This can be confirmed by taking a closer look at the error:

```
java.lang.ClassNotFoundException: RMIExploitationDemo.IExampleServiceReg
```

To fix this, create a new package on the client-side which matches the name of the server-side package. In this scenario, the package name would be `RMIExploitationDemo` and place the `IExampleServiceReg` interface into this package.

**As such, it is imperative that the package name of the interface which is defined in the client must match the package name defined on the server.**

Also as the `getService()` method in the `IExampleServiceReg` interface has a return type of `ExampleService`. The `ExampleService` interface will also need to be created in a package which matches the implementation of the server side.

Finally, the client project will look as the following:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/rmirproject.png)

After running the client, `null` should be returned and this is a good sign as a `map` in Java will return `null` if a value is not found that's associated with the key which was searched.


