---
layout: post
title: Tale of RMI Exploitation in 2021
tags: [Exploitation, Reference]
author: Ingredous Labs
comment: true
---

# Introduction
The aim of this blog post is two-fold. The first goal is to provide a detailed walkthrough of how Remote Code Execution was achieved by Deserialization via RMI. While the second goal is to provide supporting evidence of how providing source code during an engagement will yield many more findings which wouldn't have been possible to find otherwise.

During a recent engagement, a remote code execution vulnerability 

## RMI TL;DR
As the basics of RMI's inner-workings and how it can be exploited has been extensively covered in the past, this section will provide a very quick high level overview for those who might be unfamiliar with the service. References will be provided at the end of the section to resources which cover this in far greater detail.

RMI stands for Remote Method Invocation and is a Java propietary protocol. RMI is practically the object-oriented equivalent of RPC (Remote Procedure Call) and was developed to allow developers to implement client/server applications in Java. The basic functionality of RMI is that it allows an object running in one Java application (the client) to invoke methods on an object running in another Java application (the server).

RMI consists of three components:
- Server
- Client
- Registry

The responsiblity of the server is to export a remote object and bind an instance of it to the registry using a name. The registry itself is used as a lookup service (similar to how DNS works) which allows the client to lookup a name of the object instance which was bound by the server. Finally if the registry locates the instance of the object, the reference to the object (living on the server) is returned to the client. The reference that's returned to the client is known as the stub.

In order to allow the instance of the server-side object to be remotely interactable, the server must define an interface which extends the [Remote interface](https://docs.oracle.com/javase/7/docs/api/java/rmi/Remote.html#:~:text=The%20Remote%20interface%20serves%20to,rmi.). Within this interface, be sure to provide the empty method definitions for the methods which will be available to be remotely called.

The interface that's defined must be known by both the client and the server. 

Lastly, the RMI Registry can be on a separate host from the server, however its quite common to spawn the registry on the same host from where the server is running especially if there is only one application binding services to the registry.

A quick diagram is shown below to highlight the information above:
![https://miro.medium.com/max/500/0*qu96CRk57lHt_TV0](RMI Overview)

## JEP 290
2016 was a bad year for RMI as it was discovered by Moritz Bechler that it was possible to leverage exploitation in the RMI Registry by passing in a malicious serialized object as a parameter to the `bind` method of the naming registry. In order to exploit this vector, an RMI Registry must be acessible over the Internet and if so an attacker would be able to write a client which would attempt to bind a malicious object to the registry. However its not fairly common for the registry to be exposed over the Internet but rather living in the intranet. This appears to be corroborated by Shodan because as of the time of writing this post, there are only 7,030 instances of RMI Registries which can be access over the Internet. Though this may be in part due to Bechler's research. Though if an attacker is able to gain access to the internal network as a result of other means, if a host running the RMI Registry was to be discovered this could have resulted in an easy pivot (especially for red-team engagements).

In response to this, Java released JEP 290 shortly after Belcher's research. Due to the severity of the vulnerability, JEP 290 was backported to several older Java versions as well. JEP 290 introduced serialization filters which essentially mitigated this exploitation technique.

## Exploitation after JEP 290
It was discovered that it was possible to exploit RMI on the application level. Due to how RMI works, upon the client invoking a method on the stub which contains arguments, these arguments are then serialized when sent over the wire which are then deserialized on the receiving end. If the method accepts an non-primitive type argument such as Strings and Objects in Java, the `.readObject()` method is called on the argument. 

As such if a method is discovered that can be remotely invoked and accepts a non-primitive type, this can result in exploitation via deserialization as a malicious object can be passed.  However as mentioned in the blog post by Mogwai Labs, an update released in January 2020 mitigated this exploitation technique in scenarios where Strings are passed as arguments. 

The caveat here however is that an attacker will need to know how the interface which is used by the RMI service was implemented in order to have knowledge of the methods which allow for arbitrary objects to be passed.

## Method Signatures
The way that RMI determines which method should be invoked on the server by the client is by using method signatures. The way that method signatures work is that RMI generates a SHA1 hash using the method name, return type, and the argument types. The names of the arguments themselves don't make a difference. This process is done both on the client and server side. Upon the client call a method, the hashes are compared and if one matches that respective method is invoked. 

As mentioned in the section above, in a blackbox scenario where the attacker doesn't have knowledge on how the interface was implemented it would be pretty much impossible to leverage exploitation.

In response to this, [RMIScout](https://github.com/BishopFox/rmiscout) was released by BishopFox which bruteforces the method signatures of exposed RMI Interfaces to guess the method implementations. The way `RMIScout` works is by using a wordlist of signatures along with wordlist of common method names and parameter lists to attempt to determine whether such a method definition exists. Apart from the signature bruteforcing functionality, if a method is indeed discovered which is deemed vulnerable the tool can be used to leverage exploitation.

As such [RMIScout](https://github.com/BishopFox/rmiscout) is used as a last resort in black-box scenarios.

## Real World Exploitation Scenario
During a recent pentest engagement, it was discovered that there was a method which accepts an arbitary object as an argument. However the finding was only made possible due to the developers providing the source code. Without the source code, this would have been impossible to discover due to how the developers implemented RMI in this context.

Please note: the actual implementations of code shown below has been severely modified to protect the integrity of the assessment.

An interface was discovered which extends from `Remote`:
```java=
public interface IExampleServiceReg extends Remote {
    ExampleService getItem(String id) throws RemoteException;
}

The interface defines the `getItem()` method which accepts an argument of type String and returns a type of `ExampleService`.

Afterwards, the implemenation of this interface was examined:
```java=
paSer
public class ExampleServiceRegImpl extends UnicastRemoteObject implements IExampleServiceReg {
    private Map items = new HashMap();

    public ExampleServiceRegImpl() throws RemoteException { 
      ServiceA a = new ServiceA();
      items.put("Service A", a);
      ServiceB b = new ServiceB();
      items.put("Service B", b);
    }

    public ExampleService getItem(String id) throws RemoteException {
      return (ExampleService) items.get(id);
    }
}
```

As shown above, a map by the name of `items` is initalized. Further on when the constructor is called, two new objects are instantiated which are of types `ServiceA` and `ServiceB`. The respective instances of these objects are then stored in the `items` map. Finally the `getItem()` method is concretely implemented which returns a value from the `items` HashMap associated with the key which is the passed-in String.

Taking a closer look at how the server binds the remote object to the registry:

```java=
LocateRegistry.createRegistry(1099);
Naming.rebind("example_service", new ExampleServiceRegImpl());
```

An RMI Registry was spawned on port 1099, a the server registered the object to the registry with the name of `example_service`.

